/*
 * Copyright MapStruct Authors.
 *
 * Licensed under the Apache License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0
 */
package org.mapstruct.ap.spi;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiPredicate;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;

import org.mapstruct.ap.spi.util.IntrospectorUtils;

/**
 * An {@link AccessorNamingStrategy} implementation specifically designed for Protocol Buffers (Protobuf)
 * generated classes.
 *
 * <p>
 * This strategy extends {@link DefaultAccessorNamingStrategy} to handle the unique accessor patterns
 * generated by the Protocol Buffers compiler (protoc). Protobuf-generated classes have several
 * characteristics that differ from standard JavaBeans:
 * </p>
 *
 * <ul>
 *   <li>Additional auxiliary methods for various field types (e.g., {@code getXxxBytes()}, {@code getXxxCount()}, {@code getXxxOrBuilder()})</li>
 *   <li>Special handling for repeated fields using {@code getXxxList()} and {@code addAllXxx()} methods</li>
 *   <li>Special handling for map fields using {@code getXxxMap()} and {@code putAllXxx()} methods</li>
 *   <li>Enumeration fields with corresponding {@code getXxxValue()} methods for integer representations</li>
 *   <li>String fields with {@code getXxxBytes()} methods for ByteString representations</li>
 *   <li>Message fields with {@code getXxxBuilder()} and {@code getXxxOrBuilder()} methods</li>
 * </ul>
 *
 * <p>
 * This strategy filters out Protobuf-internal methods and auxiliary methods to expose only the primary
 * accessors for each field, ensuring correct mapping behavior when using MapStruct with Protobuf types.
 * </p>
 *
 * <p>
 * For non-Protobuf types, this strategy delegates to the default behavior of {@link DefaultAccessorNamingStrategy}.
 * </p>
 *
 * @author Freeman
 * @since 1.7.0
 */
public class ProtobufAccessorNamingStrategy extends DefaultAccessorNamingStrategy {
    /**
     * repeated string getter will return ProtocolStringList
     */
    private static final String PROTOCOL_STRING_LIST = "com.google.protobuf.ProtocolStringList";
    private static final String MESSAGE_LITE_OR_BUILDER = "com.google.protobuf.MessageLiteOrBuilder";
    private static final String MESSAGE_LITE = "com.google.protobuf.MessageLite";
    private static final String MESSAGE_LITE_BUILDER = "com.google.protobuf.MessageLite.Builder";
    private static final String MESSAGE = "com.google.protobuf.Message";
    private static final String MESSAGE_BUILDER = "com.google.protobuf.Message.Builder";
    private static final String PROTOCOL_MESSAGE_ENUM = "com.google.protobuf.ProtocolMessageEnum";

    private final List<SpecialMethodRule> specialGetterRules = getSpecialGetterRules();
    private final List<SpecialMethodRule> specialSetterRules = getSpecialSetterRules();

    /**
     * interface name -> set of internal method signatures
     */
    private Map<String, Set<MethodSignature>> internalMethods;

    @Override
    public void init(MapStructProcessingEnvironment processingEnvironment) {
        super.init( processingEnvironment );

        internalMethods = getInternalMethods();
    }

    @Override
    public boolean isGetterMethod(ExecutableElement method) {
        if ( !isProtobufMessageOrBuilder( method.getEnclosingElement() ) ) {
            return super.isGetterMethod( method );
        }

        return hasPrefixWithUpperCaseNext( method, "get" )
            && method.getParameters().isEmpty()
            && !isInternalMethod( method )
            && !isSpecialGetterMethod( method );
    }

    @Override
    public boolean isSetterMethod(ExecutableElement method) {
        if ( !isProtobufMessageOrBuilder( method.getEnclosingElement() ) ) {
            return super.isSetterMethod( method );
        }

        // Protobuf message only has fluent setters
        return isFluentSetter( method );
    }

    @Override
    protected boolean isFluentSetter(ExecutableElement method) {
        if ( !isProtobufMessageOrBuilder( method.getEnclosingElement() ) ) {
            return super.isFluentSetter( method );
        }

        // Only builder has setters
        if ( !isProtobufMessageBuilder( method.getEnclosingElement() ) ) {
            return false;
        }

        if ( isAddAllMethod( method ) || isPutAllMethod( method ) ) {
            return true;
        }

        return hasPrefixWithUpperCaseNext( method, "set" )
            && method.getParameters().size() == 1
            && !isInternalMethod( method )
            && !isSpecialSetterMethod( method );
    }

    @Override
    public boolean isAdderMethod(ExecutableElement method) {
        if ( !isProtobufMessageOrBuilder( method.getEnclosingElement() ) ) {
            return super.isAdderMethod( method );
        }

        // Protobuf message do have adders for repeated and putters for map fields,
        // but we uniformly use addAllXxx() and putAllXxx() methods as setters.
        // Just make life easier.
        return false;
    }

    @Override
    public boolean isPresenceCheckMethod(ExecutableElement method) {
        return super.isPresenceCheckMethod( method );
    }

    @Override
    public String getElementName(ExecutableElement adderMethod) {
        return super.getElementName( adderMethod );
    }

    @Override
    public String getPropertyName(ExecutableElement getterOrSetterMethod) {
        if ( !isProtobufMessageOrBuilder( getterOrSetterMethod.getEnclosingElement() ) ) {
            return super.getPropertyName( getterOrSetterMethod );
        }

        String methodName = getterOrSetterMethod.getSimpleName().toString();

        // 'get...Map'
        if ( isMapGetter( getterOrSetterMethod ) ) {
            return IntrospectorUtils.decapitalize( methodName.substring( 3, methodName.length() - 3 ) );
        }

        // 'get...List'
        if ( isRepeatedGetter( getterOrSetterMethod ) ) {
            return IntrospectorUtils.decapitalize( methodName.substring( 3, methodName.length() - 4 ) );
        }

        // 'addAll...'
        if ( isAddAllMethod( getterOrSetterMethod ) ) {
            return IntrospectorUtils.decapitalize( methodName.substring( 6 ) );
        }

        // 'putAll...'
        if ( isPutAllMethod( getterOrSetterMethod ) ) {
            return IntrospectorUtils.decapitalize( methodName.substring( 6 ) );
        }

        return super.getPropertyName( getterOrSetterMethod );
    }

    private Map<String, Set<MethodSignature>> getInternalMethods() {
        String[] internalClasses = {
            MESSAGE,
            MESSAGE_BUILDER,
            MESSAGE_LITE,
            MESSAGE_LITE_BUILDER,
        };

        Map<String, Set<MethodSignature>> methodsMap = new HashMap<>();
        for ( String className : internalClasses ) {
            TypeElement typeElement = elementUtils.getTypeElement( className );
            if ( typeElement != null ) {
                HashSet<MethodSignature> methods = new HashSet<>();
                collectMethods( typeElement, methods );
                methodsMap.put( className, methods );
            }
        }
        return methodsMap;
    }

    private List<SpecialMethodRule> getSpecialGetterRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();
        rules.addAll( stringGetterSpecialMethodRules() );
        rules.addAll( messageGetterGetterMethodRules() );
        rules.addAll( enumGetterSpecialMethodRules() );
        rules.addAll( repeatedGetterSpecialMethodRules() );
        rules.addAll( mapGetterSpecialMethodRules() );
        rules.addAll( oneofGetterSpecialMethodRules() );
        return rules;
    }

    private List<SpecialMethodRule> stringGetterSpecialMethodRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();

        // string field generates extra getXxxBytes() method
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "Bytes" ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "Bytes".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix )
                        && isTargetClass( m.getReturnType(), String.class )
                );
            }
        ) );

        return rules;
    }

    private List<SpecialMethodRule> messageGetterGetterMethodRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();

        // message field generates extra getXxxBuilder() method
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "Builder" ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "Builder".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix )
                        && isMessageType( m.getReturnType() )
                );
            }
        ) );

        // message field generates extra getXxxOrBuilder() method
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "OrBuilder" ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "OrBuilder".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix )
                        && isMessageType( m.getReturnType() )
                );
            }
        ) );

        // repeated message field generates extra getXxxBuilderList() method
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "BuilderList" ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "BuilderList".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix + "List" )
                        && isListType( m.getReturnType() )
                );
            }
        ) );

        // repeated message field generates extra getXxxOrBuilderList() method
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "OrBuilderList" ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "OrBuilderList".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix + "List" )
                        && isListType( m.getReturnType() )
                );
            }
        ) );

        return rules;
    }

    private List<SpecialMethodRule> enumGetterSpecialMethodRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();

        // enum field generates extra 'int getXxxValue()' method
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "Value" ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "Value".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix )
                        && isProtobufEnumType( m.getReturnType() )
                );
            }
        ) );

        // repeated enum field generates extra 'List<Integer> getXxxValueList()' method
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "ValueList" )
                && isListType( method.getReturnType() ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "ValueList".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix + "List" )
                        && isListType( m.getReturnType() )
                );
            }
        ) );

        // map<string, enum> field generates extra 'Map<String, Integer> getXxxValueMap()' method
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "ValueMap" )
                && isMapType( method.getReturnType() ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "ValueMap".length() );
                return methods.stream().anyMatch( m ->
                    ( getMethodName( m ).equals( withoutSuffix + "Map" ) || getMethodName( m ).equals( withoutSuffix ) )
                        && isMapType( m.getReturnType() )
                );
            }
        ) );

        return rules;
    }

    private List<SpecialMethodRule> repeatedGetterSpecialMethodRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();

        // repeated field generates 'getXxxCount()' method
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "Count" ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "Count".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix + "List" )
                        && isListType( m.getReturnType() )
                );
            }
        ) );

        return rules;
    }

    private List<SpecialMethodRule> mapGetterSpecialMethodRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();

        // map field generates 'getXxxCount()' method
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "Count" ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "Count".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix + "Map" )
                        && isMapType( m.getReturnType() )
                );
            }
        ) );

        // map field generates deprecated 'getXxx()' and 'getMutableXxx()' methods
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).startsWith( "get" )
                && !getMethodName( method ).endsWith( "Map" )
                && isMapType( method.getReturnType() ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                if ( methodName.startsWith( "getMutable" ) ) {
                    String withoutPrefix = methodName.substring( "getMutable".length() );
                    return methods.stream().anyMatch( m ->
                        getMethodName( m ).equals( "get" + withoutPrefix + "Map" )
                            && isMapType( m.getReturnType() )
                    );
                }
                else {
                    String withoutPrefix = methodName.substring( "get".length() );
                    return methods.stream().anyMatch( m ->
                        getMethodName( m ).equals( "get" + withoutPrefix + "Map" )
                            && isMapType( m.getReturnType() )
                    );
                }
            }
        ) );

        return rules;
    }

    private List<SpecialMethodRule> oneofGetterSpecialMethodRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();

        // oneof field generates extra 'getXxxCase()'
        rules.add( new SpecialMethodRule(
            method -> getMethodName( method ).endsWith( "Case" )
                && isEnumType( method.getReturnType() )
                && !isProtobufEnumType( method.getReturnType() ),
            (method, methods) -> true
        ) );

        return rules;
    }

    private List<SpecialMethodRule> getSpecialSetterRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();
        rules.addAll( stringSetterSpecialMethodRules() );
        rules.addAll( enumSetterSpecialMethodRules() );
        rules.addAll( messageSetterSpecialMethodRules() );
        return rules;
    }

    private List<SpecialMethodRule> stringSetterSpecialMethodRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();

        // string field generates extra setXxxBytes() method
        rules.add( new SpecialMethodRule(
            method -> hasPrefixWithUpperCaseNext( method, "set" )
                && getMethodName( method ).endsWith( "Bytes" ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "Bytes".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix )
                        && isFirstParameterTargetClass( m, String.class )
                );
            }
        ) );

        return rules;
    }

    private List<SpecialMethodRule> enumSetterSpecialMethodRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();

        // enum field generates extra 'setXxxValue(int)' method
        rules.add( new SpecialMethodRule(
            method -> hasPrefixWithUpperCaseNext( method, "set" )
                && getMethodName( method ).endsWith( "Value" )
                && isFirstParameterTargetClass( method, int.class ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "Value".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix )
                        && m.getParameters().size() == 1
                        && isProtobufEnumType( m.getParameters().get( 0 ).asType()
                    ) );
            }
        ) );

        // repeated enum field generates extra 'addAllXxxValue(Iterable<Integer> values)' method
        // addAllXxx(Iterable<EnumType> values)
        rules.add( new SpecialMethodRule(
            method -> hasPrefixWithUpperCaseNext( method, "addAll" )
                && getMethodName( method ).endsWith( "Value" )
                && isFirstParameterTargetClass( method, Iterable.class ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "Value".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix )
                        && isFirstParameterTargetClass( m, Iterable.class )
                );
            }
        ) );

        // map<string, enum> field generates extra 'putAllXxxValue(Map<String, Integer> values)' method
        // putAllXxx(Map<String, EnumType> values)
        rules.add( new SpecialMethodRule(
            method -> hasPrefixWithUpperCaseNext( method, "putAll" )
                && getMethodName( method ).endsWith( "Value" )
                && isFirstParameterTargetClass( method, Map.class ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                String withoutSuffix = methodName.substring( 0, methodName.length() - "Value".length() );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( withoutSuffix )
                        && isFirstParameterTargetClass( m, Map.class )
                );
            }
        ) );

        return rules;
    }

    private List<SpecialMethodRule> messageSetterSpecialMethodRules() {
        List<SpecialMethodRule> rules = new ArrayList<>();

        // message field generates extra setXxx(Message.Builder builder) method
        rules.add( new SpecialMethodRule(
            method -> hasPrefixWithUpperCaseNext( method, "set" )
                && isFirstParameterTargetSubType( method, MESSAGE_LITE_BUILDER ),
            (method, methods) -> {
                String methodName = getMethodName( method );
                return methods.stream().anyMatch( m ->
                    getMethodName( m ).equals( methodName )
                        && isFirstParameterTargetSubType( m, MESSAGE_LITE )
                );
            }
        ) );

        return rules;
    }

    private static boolean isFirstParameterTargetClass(ExecutableElement method, String canonicalName) {
        return method.getParameters().size() == 1
            && isTargetClass( method.getParameters().get( 0 ).asType(), canonicalName );
    }

    private boolean isFirstParameterTargetSubType(ExecutableElement method, String canonicalName) {
        return method.getParameters().size() == 1
            && isTargetSubType( method.getParameters().get( 0 ).asType(), canonicalName );
    }

    private static boolean isFirstParameterTargetClass(ExecutableElement method, Class<?> targetClass) {
        return isFirstParameterTargetClass( method, targetClass.getCanonicalName() );
    }

    private boolean isSpecialGetterMethod(ExecutableElement method) {
        List<ExecutableElement> allMethods = getPublicNonStaticMethods( method.getEnclosingElement() );
        for ( SpecialMethodRule rule : specialGetterRules ) {
            if ( rule.matches( method, allMethods ) ) {
                return true;
            }
        }
        return false;
    }

    private boolean isSpecialSetterMethod(ExecutableElement method) {
        List<ExecutableElement> allMethods = getPublicNonStaticMethods( method.getEnclosingElement() );
        for ( SpecialMethodRule rule : specialSetterRules ) {
            if ( rule.matches( method, allMethods ) ) {
                return true;
            }
        }
        return false;
    }

    private boolean isAddAllMethod(ExecutableElement method) {
        return hasPrefixWithUpperCaseNext( method, "addAll" )
            && isFirstParameterTargetClass( method, Iterable.class )
            && !isSpecialSetterMethod( method );
    }

    private boolean isPutAllMethod(ExecutableElement method) {
        return hasPrefixWithUpperCaseNext( method, "putAll" )
            && isFirstParameterTargetClass( method, Map.class )
            && !isSpecialSetterMethod( method );
    }

    private static boolean isTargetClass(TypeMirror paramType, Class<?> targetType) {
        return isTargetClass( paramType, targetType.getCanonicalName() );
    }

    private static boolean isTargetClass(TypeMirror paramType, String canonicalName) {
        return paramType.toString().startsWith( canonicalName );
    }

    private boolean isProtobufEnumType(TypeMirror t) {
        if ( t.getKind() != TypeKind.DECLARED ) {
            return false;
        }

        TypeElement protobufEnumElement = elementUtils.getTypeElement( PROTOCOL_MESSAGE_ENUM );
        if ( protobufEnumElement == null ) {
            return false;
        }

        TypeMirror protobufEnumType = protobufEnumElement.asType();
        return typeUtils.isSubtype( t, protobufEnumType );
    }

    private boolean isEnumType(TypeMirror t) {
        if ( t.getKind() != TypeKind.DECLARED ) {
            return false;
        }
        Element element = ( (DeclaredType) t ).asElement();
        return element.getKind() == ElementKind.ENUM;
    }

    private boolean isRepeatedGetter(ExecutableElement element) {
        // repeated fields getter: getXxxList()
        return hasPrefixWithUpperCaseNext( element, "get" )
            && getMethodName( element ).endsWith( "List" )
            && isListType( element.getReturnType() );
    }

    private boolean isMapGetter(ExecutableElement element) {
        // There are many getter methods for map in protobuf generated code, only one is the real getter:
        // - getXxx deprecated
        // - getMutableXxx deprecated
        // - getXxxMap the real getter
        if ( hasPrefixWithUpperCaseNext( element, "get" )
            && getMethodName( element ).endsWith( "Map" )
            && isMapType( element.getReturnType() ) ) {
            List<ExecutableElement> allMethods = getPublicNonStaticMethods( element.getEnclosingElement() );
            for ( SpecialMethodRule rule : mapGetterSpecialMethodRules() ) {
                if ( rule.matches( element, allMethods ) ) {
                    return false;
                }
            }
            return true;
        }

        return false;
    }

    private static String getMethodName(ExecutableElement element) {
        return element.getSimpleName().toString();
    }

    private static boolean isListType(TypeMirror t) {
        return isTargetClass( t, List.class ) || t.toString().startsWith( PROTOCOL_STRING_LIST );
    }

    private static boolean isMapType(TypeMirror t) {
        return isTargetClass( t, Map.class );
    }

    private boolean isProtobufMessageOrBuilder(Element type) {
        if ( !( type instanceof TypeElement ) ) {
            return false;
        }

        TypeElement typeElement = (TypeElement) type;
        return isMessageOrBuilderType( typeElement.asType() );
    }

    private boolean isProtobufMessageBuilder(Element type) {
        if ( !( type instanceof TypeElement ) ) {
            return false;
        }

        TypeElement typeElement = (TypeElement) type;
        return isMessageBuilderType( typeElement.asType() );
    }

    private boolean isMessageOrBuilderType(TypeMirror t) {
        return isTargetSubType( t, MESSAGE_LITE_OR_BUILDER );
    }

    private boolean isMessageBuilderType(TypeMirror t) {
        return isTargetSubType( t, MESSAGE_LITE_BUILDER );
    }

    private boolean isMessageType(TypeMirror t) {
        return isTargetSubType( t, MESSAGE_LITE );
    }

    private boolean isTargetSubType(TypeMirror t, String canonicalName) {
        if ( t.getKind() != TypeKind.DECLARED ) {
            return false;
        }

        TypeElement messageType = elementUtils.getTypeElement( canonicalName );
        if ( messageType == null ) {
            return false;
        }

        return typeUtils.isSubtype( t, messageType.asType() );
    }

    private boolean isInternalMethod(ExecutableElement method) {
        Element enclosingElement = method.getEnclosingElement();
        if ( !( enclosingElement instanceof TypeElement ) ) {
            return false;
        }

        TypeElement typeElement = (TypeElement) enclosingElement;
        MethodSignature signature = new MethodSignature( method );

        // Check all interfaces and superclasses of the enclosing type
        for ( Map.Entry<String, Set<MethodSignature>> entry : internalMethods.entrySet() ) {
            String interfaceName = entry.getKey();
            Set<MethodSignature> internalMethods = entry.getValue();

            TypeElement interfaceElement = elementUtils.getTypeElement( interfaceName );
            if ( interfaceElement != null && typeUtils.isSubtype( typeElement.asType(), interfaceElement.asType() ) ) {
                if ( internalMethods.contains( signature ) ) {
                    return true;
                }
            }
        }

        return false;
    }

    private static void collectMethods(TypeElement typeElement, HashSet<MethodSignature> methods) {
        // Collect methods from current type
        for ( Element element : typeElement.getEnclosedElements() ) {
            if ( element instanceof ExecutableElement && isPublicNonStaticMethod( (ExecutableElement) element ) ) {
                methods.add( new MethodSignature( (ExecutableElement) element ) );
            }
        }

        // Collect from superclass
        TypeMirror superclass = typeElement.getSuperclass();
        if ( superclass instanceof DeclaredType ) {
            DeclaredType declaredType = (DeclaredType) superclass;
            Element superElement = declaredType.asElement();
            if ( superElement instanceof TypeElement && !superElement.toString().equals( "java.lang.Object" ) ) {
                collectMethods( (TypeElement) superElement, methods );
            }
        }

        // Collect from interfaces
        for ( TypeMirror interfaceType : typeElement.getInterfaces() ) {
            if ( interfaceType instanceof DeclaredType ) {
                DeclaredType declaredType = (DeclaredType) interfaceType;
                Element interfaceElement = declaredType.asElement();
                if ( interfaceElement instanceof TypeElement ) {
                    collectMethods( (TypeElement) interfaceElement, methods );
                }
            }
        }
    }

    private static List<ExecutableElement> getPublicNonStaticMethods(Element type) {
        return type
            .getEnclosedElements()
            .stream()
            .filter( e -> {
                if ( e instanceof ExecutableElement ) {
                    return isPublicNonStaticMethod( (ExecutableElement) e );
                }
                else {
                    return false;
                }
            } )
            .map( e -> (ExecutableElement) e )
            .collect( Collectors.toList() );
    }

    private static boolean isPublicNonStaticMethod(ExecutableElement method) {
        Set<Modifier> modifiers = method.getModifiers();
        return method.getKind() == ElementKind.METHOD
            && modifiers.contains( Modifier.PUBLIC )
            && !modifiers.contains( Modifier.STATIC );
    }

    private static boolean hasPrefixWithUpperCaseNext(ExecutableElement method, String prefix) {
        String name = method.getSimpleName().toString();
        int len = prefix.length();
        return name.startsWith( prefix )
            && name.length() > len
            && Character.isUpperCase( name.charAt( len ) );
    }

    /**
     * Represents a rule for detecting special Protobuf-generated methods.
     *
     * <p>
     * Special methods are auxiliary methods generated by protoc (like getXxxBytes(), getXxxCount(), etc.)
     * that should not be treated as normal getters/setters.
     *
     * <p>
     * The rule has two stages:
     * 1. Quick check: Fast preliminary check based on method signature (e.g., method name ends with "Bytes")
     * 2. Full check: Complete verification by checking if corresponding primary method exists
     */
    private static final class SpecialMethodRule {
        private final Predicate<ExecutableElement> quickCheck;
        private final BiPredicate<ExecutableElement, List<ExecutableElement>> fullCheck;

        public SpecialMethodRule(
            Predicate<ExecutableElement> quickCheck,
            BiPredicate<ExecutableElement, List<ExecutableElement>> fullCheck) {
            this.quickCheck = quickCheck;
            this.fullCheck = fullCheck;
        }

        public boolean matches(ExecutableElement method, List<ExecutableElement> allMethods) {
            return quickCheck.test( method ) && fullCheck.test( method, allMethods );
        }

        public boolean matches(ExecutableElement method) {
            List<ExecutableElement> allMethods = getPublicNonStaticMethods( method.getEnclosingElement() );
            return quickCheck.test( method ) && fullCheck.test( method, allMethods );
        }
    }

    private static final class MethodSignature {
        private final String name;
        private final List<String> parameterTypes;

        public MethodSignature(ExecutableElement method) {
            this.name = method.getSimpleName().toString();
            this.parameterTypes = method.getParameters().stream()
                .map( p -> p.asType().toString() )
                .collect( Collectors.toList() );
        }

        @Override
        public boolean equals(Object o) {
            if ( o == null || getClass() != o.getClass() ) {
                return false;
            }
            MethodSignature that = (MethodSignature) o;
            return Objects.equals( name, that.name ) && Objects.equals( parameterTypes, that.parameterTypes );
        }

        @Override
        public int hashCode() {
            return Objects.hash( name, parameterTypes );
        }

        @Override
        public String toString() {
            return name + "(" + String.join( ", ", parameterTypes ) + ")";
        }
    }

}