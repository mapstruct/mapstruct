[[defining-mapper]]
== 定义一个mapper

在本节中，您将学到如何用MapStruct定义bean mapper，以及有哪些配置选项。

[[basic-mappings]]
=== 基本映射

创建一个mapper类很简单，仅需简单定义一个Java接口，加上需要的映射方法，并给接口加上 `org.mapstruct.Mapper` 注解就可以：

.Java interface to define a mapper
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
@Mapper
public interface CarMapper {

    @Mapping(target = "manufacturer", source = "make")
    @Mapping(target = "seatCount", source = "numberOfSeats")
    CarDto carToCarDto(Car car);

    @Mapping(target = "fullName", source = "name")
    PersonDto personToPersonDto(Person person);
}
----
====

在构建期，`@Mapper` 注解会触发MapStruct代码生成器，从而生成 `CarMapper` 接口的实现类。

在生成的方法实现中，所有source类（比如 `Car` ）的可读字段，都会被复制到target类（比如 `CarDto` ）中的对应字段：

* 当字段名称与target类中对应字段的名称一致时，映射会是隐式的
* 当字段名称与target类中对应字段的名称不一致时，可以通过 `@Mapping` 注解来完成映射。

[TIP]
====
在 `@mapping` 注解中，必须制定字段名（需符合 http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html[JavaBeans specification]）。如上例中的 _seatCount_ 字段，并且该字段有 `getSeatCount()` 和 `setSeatCount()` 方法。

====
[TIP]
====
通过指定 `@BeanMapping(ignoreByDefault = true)` ，默认行为会变成 *显式映射*。即所有映射都需要通过 `@Mapping` 方式指定，没映射到的target字段也不会有warning信息。
====
[TIP]
====
支持链式setter。
链式setter就是返回值类型和修改值类型一致的setter。

如：

```
public Builder seatCount(int seatCount) {
    this.seatCount = seatCount;
    return this;
}
```
====

为了更好地明白MapStruct做了什么，我们可以看一下MapStruct生成的 `carToCarDto()` 实现：

.Code generated by MapStruct
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
// GENERATED CODE
public class CarMapperImpl implements CarMapper {

    @Override
    public CarDto carToCarDto(Car car) {
        if ( car == null ) {
            return null;
        }

        CarDto carDto = new CarDto();

        if ( car.getFeatures() != null ) {
            carDto.setFeatures( new ArrayList<String>( car.getFeatures() ) );
        }
        carDto.setManufacturer( car.getMake() );
        carDto.setSeatCount( car.getNumberOfSeats() );
        carDto.setDriver( personToPersonDto( car.getDriver() ) );
        carDto.setPrice( String.valueOf( car.getPrice() ) );
        if ( car.getCategory() != null ) {
            carDto.setCategory( car.getCategory().toString() );
        }
        carDto.setEngine( engineToEngineDto( car.getEngine() ) );

        return carDto;
    }

    @Override
    public PersonDto personToPersonDto(Person person) {
        //...
    }

    private EngineDto engineToEngineDto(Engine engine) {
        if ( engine == null ) {
            return null;
        }

        EngineDto engineDto = new EngineDto();

        engineDto.setHorsePower(engine.getHorsePower());
        engineDto.setFuel(engine.getFuel());

        return engineDto;
    }
}
----
====

MapStruct生成代码的哲学是：尽量让生成的代码和手写的代码一样。具体来讲，是通过普通的getter/setter方法调用完成值从source到target的复制，而不是通过反射或类似的其他方式。

如上例中所展示的一样，生成的代码中包含 `@Mapping` 指定的所有名称映射。

如果source和target间要映射字段的类型不一样时，MapStruct要么会进行自动类型转换（例如上例中的 _price_ 字段，详见 <<implicit-type-conversions>> ），要么会选择性地调用/创建另一个映射方法（例如上例中的 _driver_ / _engine_ 字段，详见 <<implicit-type-conversions>>）。

另外当且仅当以下条件得到满足时，MapStruct才会创建另一个新的映射方法：1. source字段和target字段都是一个Bean中的字段。2. source字段和target字段本身是Bean或简单字段（即不是 `Collection` 或者 `Map` 类型）

字段是集合类型时：

. source和target字段是元素类型相同的集合，则映射就是创建一个包含source全部实例的target类型的集合实例。
. source和target字段是元素类型不同的集合，则每个source元素都会先被独立映射为target元素，之后再添加到target集合中（参见<<mapping-collections>>）

MapStruct会考虑source类和target类中的所有公共字段，包括其父类中的字段。

[[mapping-composition]]
=== Mapping Composition (experimental)

MapStruct支持元注解。

`@Mapping` 注解的 `@Target` （译注：即作用范围），不仅支持支持 `ElementType#METHOD` （译注：即方法），还支持 `ElementType#ANNOTATION_TYPE` （译注：即注解）。这允许 `@Mapping` 在用户自定义的其他注解上使用，以达到复用的目的，比如：

====
[source, java, linenums]
[subs="verbatim,attributes"]
----
@Retention(RetentionPolicy.CLASS)
@Mapping(target = "id", ignore = true)
@Mapping(target = "creationDate", expression = "java(new java.util.Date())")
@Mapping(target = "name", source = "groupName")
public @interface ToEntity { }
----
====

`@ToEntity` 所添加的需要有一些共同特征，但是这些类不需要有一个公共基类。举个例子，下面 `StorageMapper` 中，`ShelveEntity` 和 `BoxEntity` 并没有同一个基类。

====
[source, java, linenums]
[subs="verbatim,attributes"]
----
@Mapper
public interface StorageMapper {

    StorageMapper INSTANCE = Mappers.getMapper( StorageMapper.class );

    @ToEntity
    @Mapping( target = "weightLimit", source = "maxWeight")
    ShelveEntity map(ShelveDto source);

    @ToEntity
    @Mapping( target = "label", source = "designation")
    BoxEntity map(BoxDto source);
}
----
====

但是，`ShelveEntity` 和 `BoxEntity` 确实有一些公共字段。`@ToEntity` 假定 `ShelveEntity` 和 `BoxEntity` 都拥有字段：`"id"`, `"creationDate"` 和 `"name"`。其进一步假定作为source bean的 `ShelveDto` 和 `BoxDto` 都有 `"groupName"` 字段。此概念也被人称为“鸭子类型”，如果一个东西叫起来像鸭子，走起来像鸭子，那它可以当鸭子对待。

此功能仍处于试验阶段。报错信息还不成熟：出问题的方法以及 `@Mapping` 注解中的相关值都会显示出来，但是，组合的切面是不可见的。错误消息对应的情况就像是 `@Mapping` 是直接加在相关的方法上一样。

因此，用户应该小心使用该特性，特别是在不确定一个字段是否会始终存在的情况下。

一个更加类型安全（但也更繁琐）的方式是：在target bean和source bean上定义基类/接口，并且使用 `@InheritConfiguration` 达到相同的结果（详见<<mapping-configuration-inheritance>>）。

[[adding-custom-methods]]
=== 给mapper添加自定义方法

在某些场景下，您需要手动实现一些MapStruct不能自动生成的特定映射。一种方法是在另一个类里手动实现自定义的映射方法，之后再使MapStruct生成的mapper类调用这个方法（参见 <<invoking-other-mappers>>）。

而如果您用的是java8或者更高的版本，您可以直接在mapper接口中实现自定义的方法（即default方法）作为代替。如果参数的类型和返回值的类型与default方法匹配，MapStruct生成的代码会自动调用default方法。

我们可以看个例子，有一个把 `Person` 映射到 `PersonDto` 的需求，里面有一些特殊逻辑，不能用MapStruct自动生成对应代码。您可以这样定义这个mapper：

.Mapper which defines a custom mapping with a default method
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
@Mapper
public interface CarMapper {

    @Mapping(...)
    ...
    CarDto carToCarDto(Car car);

    default PersonDto personToPersonDto(Person person) {
        //hand-written mapping logic
    }
}
----
====

MapStruct代码生成器会生成 `carToCarDto()` 方法的实现。当其中需要映射 `driver` 字段时，MapStruct会调用我们手动实现的 `personToPersonDto()` 方法生成代码。

一个mapper也可以不定义成一个接口，而定义成一个抽象类并在里面实现自定义方法。在这种情况下，MapStruct会生成抽象类的子类，并实现所有的抽象方法。这种方式相较于声明接口+default方法的一个优势是类中可以声明额外的变量字段。

所以，刚才把 Person 映射到 PersonDto 的例子也可以这样写：

.Mapper defined by an abstract class
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
@Mapper
public abstract class CarMapper {

    @Mapping(...)
    ...
    public abstract CarDto carToCarDto(Car car);

    public PersonDto personToPersonDto(Person person) {
        //hand-written mapping logic
    }
}
----
====

MapStruct会生成 `CarMapper` 的子类，里面会有 `carToCarDto()` 方法的实现（因为该方法被声明为抽象方法）。而 `carToCarDto()` 的实现中，当需要映射 `driver` 字段时，会调用我们手动实现的 `personToPersonDto()` 方法。

[[mappings-with-several-source-parameters]]
=== 带有多个source参数的映射方法

MapStruct也支持带有多个source参数的映射方法。因此您可以把多个实体组合成一个目标对象。例子如下：

.Mapping method with several source parameters
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
@Mapper
public interface AddressMapper {

    @Mapping(target = "description", source = "person.description")
    @Mapping(target = "houseNumber", source = "address.houseNo")
    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);
}
----
====

上例中，映射方法把两个source对象映射成了一个target对象。和单参数映射方法一样，字段是通过名字映射的。

如果这多个source参数里有字段名称冲突(重复)的，则必须使用 `@Mapping` 注解指明字段来源自哪个参数，如上例中的 `description`。当有冲突问题未解决时，在编译时则会报错。至于名字不冲突的字段，则无需指明来源。

[WARNING]
====
当使用 `@Mapping` 注解的时候，必须指定字段来源自哪个参数（译注：仅针对多参数映射的情况）
====

[TIP]
====
仅当所有source参数都是 `null` 时，多参数mapping方法才返回 `null`。不然target对象就会被实例化，并且按照提供的参数塞字段进去。
====

您也可以直接指向source参数，例子如下：

.Mapping method directly referring to a source parameter
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
@Mapper
public interface AddressMapper {

    @Mapping(target = "description", source = "person.description")
    @Mapping(target = "houseNumber", source = "hn")
    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Integer hn);
}
----
====

这个例子里，source参数被直接映射进了target对象中，即参数 `hn` （一个非bean类型，这里是 `java.lang.Integer` ）被映射为了 `houseNumber` 。

[[mapping-nested-bean-properties-to-current-target]]
=== 把嵌套bean的属性映射到target对象中

如果您不想显式地为所有来自嵌套source bean的字段指定名称，您可以用 `.` 作为target。这会让MapStruct把source bean中的每个属性都映射到target对象中。例子如下：

.use of "target this" annotation "."
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
 @Mapper
 public interface CustomerMapper {

     @Mapping( target = "name", source = "record.name" )
     @Mapping( target = ".", source = "record" )
     @Mapping( target = ".", source = "account" )
     Customer customerDtoToCustomer(CustomerDto customerDto);
 }
----
====

生成的代码会把 `CustomerDto.record` 里面的每个属性都直接映射到 `Customer` 里，您也就无需手动进行名称指定，`Customer.account` 也是如此。

如果有冲突，您可以通过显式指定mapping来解决。举个例子，假设上例中的 `CustomerDto.record` 和 `CustomerDto.account` 都有字段 `name`，则您可以通过指定 `@Mapping( target = "name", source = "record.name" )` 来解决这个冲突。

这个“target this”的概念在把有层级结构的对象在映射中打平时特别有用，相反的情形也是一样(`@InheritInverseConfiguration`)。

[[updating-bean-instances]]
=== 更新已经存在的bean实例

在一些场景中，您的需求不是创建一个新的target实例，而是更新一个已经存在的target实例。

您可以这样实现此类映射：1.把target对象添加为参数 2. 给该参数添加 `@MappingTarget` 注解。

例子如下：

.Update method
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
@Mapper
public interface CarMapper {

    void updateCarFromDto(CarDto carDto, @MappingTarget Car car);
}
----
====

在 `updateCarFromDto()` 的方法实现中，会用 `CarDto` 对象中的字段去更新传进去的 `Car` 实例。
这里只有一个参数被标记为MappingTarget。

您也可以把target参数的类型当作返回值类型，而不是 `void` 。这样生成的方法实现中会把传进来target实例更新并返回。这种方式可以允许映射方法进行链式调用。

当使用 `CollectionMappingStrategy.ACCESSOR_ONLY` 标签时，target bean中集合/map类型的字段会先被清空，之后再塞进来自source的对应集合/map字段的元素。
当使用 `CollectionMappingStrategy.ADDER_PREFERRED` 或者 `CollectionMappingStrategy.TARGET_IMMUTABLE` 标签时，target字段不会被清空，而是直接塞元素进去。

[[direct-field-mappings]]
=== 使用直接字段访问的映射

MapStruct也支持没有getters/setters方法的public字段的映射。
当找不到某字段的getter/setter时，MapStruct会直接使用该字段作为读/写的访问器（accessor）。

当一个字段被标为 `public` 或者 `public final` 时，该字段会被认为是一个读访问器。当一个字段被标为 `static` 时，该字段就不再被当成读访问器。

仅当一个字段被标为 `public` 时，该字段会被认为是一个读访问器。当一个字段被标为 `final` 或 `static` 时，该字段就不再被当成读访问器。

举个小例子：

.Example classes for mapping
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
public class Customer {

    private Long id;
    private String name;

    //getters and setter omitted for brevity
}

public class CustomerDto {

    public Long id;
    public String customerName;
}

@Mapper
public interface CustomerMapper {

    CustomerMapper INSTANCE = Mappers.getMapper( CustomerMapper.class );

    @Mapping(target = "name", source = "customerName")
    Customer toCustomer(CustomerDto customerDto);

    @InheritInverseConfiguration
    CustomerDto fromCustomer(Customer customer);
}
----
====

对于上面的配置，生成的mapper如下：

.Generated mapper for example classes
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
// GENERATED CODE
public class CustomerMapperImpl implements CustomerMapper {

    @Override
    public Customer toCustomer(CustomerDto customerDto) {
        // ...
        customer.setId( customerDto.id );
        customer.setName( customerDto.customerName );
        // ...
    }

    @Override
    public CustomerDto fromCustomer(Customer customer) {
        // ...
        customerDto.id = customer.getId();
        customerDto.customerName = customer.getName();
        // ...
    }
}
----
====

完整的例子见于github上的 https://github.com/mapstruct/mapstruct-examples/tree/master/mapstruct-field-mapping[mapstruct-examples-field-mapping] 项目。

[[mapping-with-builders]]
=== 使用builder

MapStruct也支持通过builder来对不可变类型进行映射。
当执行映射时，MapStruct会检查被映射的类型是否有builder，这通过 `BuilderProvider` SPI完成。如果该类型确实存在Builder，则该Builder会在mapping中使用。

默认的BuilderProvider实现采用如下假设：

* 该类应有一个无参的public static的builder创建方法，该方法的返回值即是该类builder。举例来讲，假设有一个符合该标准 `Person` 类，那么它就应该有一个返回 `PersonBuilder` 的public static的方法。
* 该builder类应有一个无参的public方法(build 方法)，该方法的返回值是被构建的类型。举例来讲，`PersonBuilder` 中就有一个返回 `Person` 的方法。
* 如果有多个build方法，MapStruct会寻找有没有一个名字就叫 `build` 的方法，如果有，那么MapStruct就会采用该方法，否则就会在编译时报错。
* 一个具体的build方法可以通过在 `@BeanMapping` , `@Mapper` 和 `@MapperConfig` 注解中使用 `@Builder` 实现。
* 如果有多个满足上面条件的builder创建方法，那么 `DefaultBuilderProvider` SPI会抛出 `MoreThanOneBuilderCreationMethodException` 异常。MapStruct会捕获这个异常，并且在编译时抛出报警信息并且不用任何builder。

当MapStruct发现了该类确实满足条件后，MapStruct生成的代码就会调用builder的build方法来完成映射。

[NOTE]
======
对builder的探测可以通过 `@Builder#disableBuilder` 关闭。当builder被禁用后，MapStruct会使用一般的getters / setters。
======

[NOTE]
======
<<object-factories>> 也被认为是builder模式。

比如，如果一个object factory中有`PersonBuilder`，那么这个工厂就会替代builder创建方法而被使用。
======

[NOTE]
======
被探测到的builder会影响 `@BeforeMapping` 和 `@AfterMapping` 注解的行为，更多请参见 <<Mapping customization with before-mapping and after-mapping methods>>。

======

.Person with Builder example
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
public class Person {

    private final String name;

    protected Person(Person.Builder builder) {
        this.name = builder.name;
    }

    public static Person.Builder builder() {
        return new Person.Builder();
    }

    public static class Builder {

        private String name;

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Person create() {
            return new Person( this );
        }
    }
}
----
====

.Person Mapper definition
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
public interface PersonMapper {

    Person map(PersonDto dto);
}
----
====

.Generated mapper with builder
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
// GENERATED CODE
public class PersonMapperImpl implements PersonMapper {

    public Person map(PersonDto dto) {
        if (dto == null) {
            return null;
        }

        Person.Builder builder = Person.builder();

        builder.name( dto.getName() );

        return builder.create();
    }
}
----
====

支持builder的框架：

* https://projectlombok.org/[Lombok] - 您需要在模块中引入Lombok包。
更多信息参见 https://github.com/rzwitserloot/lombok/issues/1538[rzwitserloot/lombok#1538] 为了让lombok和mapstruct一起工作，请参见 <<lombok>>。译注：lombok和mapstruct都是通过修改字节码的方式实现功能，有一定的冲突问题，需要额外配置来解决冲突）
* https://github.com/google/auto/blob/master/value/userguide/index.md[AutoValue]
* https://immutables.github.io/[Immutables] - 当Immutables出现在注解处理器的路径上时，`ImmutablesAccessorNamingStrategy` 和 `ImmutablesBuilderProvider` 会被用作默认方法。
* https://github.com/google/FreeBuilder[FreeBuilder] - 当FreeBuilder出现在注解处理器的路径上时，`FreeBuilderAccessorNamingStrategy` 会被用作默认方法。当使用FreeBuilder时，JavaBean 规范应当被遵守，不然MapStruct无法识别流式getter。
* 自定义builder（手写的）也适用，只要满足默认BuilderProvider的规则。

不然，您就要写一个自定义的BuilderProvider。

[TIP]
====
如果您想要关闭builder，您可以把MapStruct处理器选项 `mapstruct.disableBuilders` 传给编译器，例如 `-Amapstruct.disableBuilders=true` 。
====

[[mapping-with-constructors]]
=== 使用构造器

MapStruct支持使用构造器来构建target类型。

在映射过程中，MapStruct会检查被映射类是否有builder，如果没有，则MapStruct会找该类的一个构造器,如果该类有多个构造器，则MapStruct会按照下列方式挑选哪一个构造器应该被使用：

* 如果一个构造器上有注解 `@Default`（来自任何包都可以，参见<<non-shipped-annotations>>），则该构造器会被采用。
* 如果仅有一个public的构造器，则该构造器会被采用，其他非public构造器会被忽略。
* 如果一个无参构造器存在，则该构造器会被采用，其他构造器会被忽略。
* 如果有多个符合标准的构造器，那么编译时会抛出未指明构造器的异常。此时，可以用 `@Default` 注解（来自任何包都可以，参见<<non-shipped-annotations>>）解决该问题。

.Deciding which constructor to use
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
public class Vehicle {

    protected Vehicle() { }

    // MapStruct will use this constructor, because it is a single public constructor
    public Vehicle(String color) { }
}

public class Car {

    // MapStruct will use this constructor, because it is a parameterless empty constructor
    public Car() { }

    public Car(String make, String color) { }
}

public class Truck {

    public Truck() { }

    // MapStruct will use this constructor, because it is annotated with @Default
    @Default
    public Truck(String make, String color) { }
}

public class Van {

    // There will be a compilation error when using this class because MapStruct cannot pick a constructor

    public Van(String make) { }

    public Van(String make, String color) { }

}
----
====

当使用构造函数时，将使用构造函数参数的名称来匹配target字段。当该构造器有 `@ConstructorProperties` 注解时（来自任何包都可以，参见 <<non-shipped-annotations>> ），那么将使用这个注解获取参数的名称。

[NOTE]
====
当存在一个object factory方法或者一个有 `@ObjectFactory` 注解的方法，该方法会比target类中所有构造器的优先级更高。

此时target对象的构造器不会被使用。
====


.Person with constructor parameters
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
public class Person {

    private final String name;
    private final String surname;

    public Person(String name, String surname) {
        this.name = name;
        this.surname = surname;
    }
}
----
====

.Person With Constructor Mapper definition
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
public interface PersonMapper {

    Person map(PersonDto dto);
}
----
====

.Generated mapper with constructor
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
// GENERATED CODE
public class PersonMapperImpl implements PersonMapper {

    public Person map(PersonDto dto) {
        if (dto == null) {
            return null;
        }

        String name;
        String surname;
        name = dto.getName();
        surname = dto.getSurname();

        Person person = new Person( name, surname );

        return person;
    }
}
----
====

[[mapping-map-to-bean]]
=== 将Map映射为Bean


有时候，您想要将 `Map<String, ???>` 映射为具体的bean。
MapStruct可以提供上述场景所需的映射能力：使用target bean字段（或者通过 `Mapping#source` 定义）来将map中的values抽出以完成映射。

例子如下：

.Example classes for mapping map to bean
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
public class Customer {

    private Long id;
    private String name;

    //getters and setter omitted for brevity
}

@Mapper
public interface CustomerMapper {

    @Mapping(target = "name", source = "customerName")
    Customer toCustomer(Map<String, String> map);

}
----
====

.Generated mapper for mapping map to bean
====
[source, java, linenums]
[subs="verbatim,attributes"]
----
// GENERATED CODE
public class CustomerMapperImpl implements CustomerMapper {

    @Override
    public Customer toCustomer(Map<String, String> map) {
        // ...
        if ( map.containsKey( "id" ) ) {
            customer.setId( Integer.parseInt( map.get( "id" ) ) );
        }
        if ( map.containsKey( "customerName" ) ) {
            customer.setName( map.get( "customerName" ) );
        }
        // ...
    }
}
----
====

[NOTE]
====
所有之前提到过的规则，如在不同类型之间映射的规则；通过 `Mapper#uses` 使用其他mapper的方式；mapper中的自定义方法等等，此处都同样使用。

举例来讲，您可以将 `Map<String, Integer>` 映射为一个Bean，但是每个字段都需要一个从 `Integer` 类型转换为target中对应字段类型的类型转换。
====

[WARNING]
====
当使用一个raw map(译注：即不使用泛型的map)或者不使用String作为key的map时，MapStruct会生成一个warning。但是如果该map直接被映射为target字段，则不会生成该warning。
====
